import math
import numpy

class Equation(): #y' = sin(x) + y
    
    def get_derivative(self, x, y):
        
        #return math.sin(numpy.deg2rad(x)) + y
        print(x, math.sin(x))
        return math.sin(x) + y
    
    def rad2deg(self, x): #converting radians to degrees
        
        return (2.0 * math.pi * x/360.0)
        
    def __init__(self, x0, y0, X, n):
        self.x0 = x0
        self.y0 = y0
        self.X = X
        self.n = n
        
        h = (X - x0)/n
        self.h = h
        
        print(x0, X, h)
        
        self.x = numpy.arange(x0, X + 0.000001, h)
        print(self.x)
        
class Numeric_methods():
    
    def euler_method(self, f):
    
        y = [0] * len(f.x)
        y[0] = f.y0
    
        for i in range(1, len(f.x)):
            y[i] = y[i - 1] + f.h * f.get_derivative(f.x[i - 1], y[i - 1]) #augmentation
            
        return y
        
    def euler_improved(self, f):
        
        y = [0] * len(f.x)
        y[0] = f.y0
        
        for i in range(1, len(f.x)):
            d = f.h * f.get_derivative(f.x[i - 1] + f.h/2, y[i - 1] + f.h/2 * f.get_derivative(x[i - 1], y[i - 1]))
            y[i] = y[i - 1] + d #augmentation
            
        return y
        
    def runge_kutta(self, f):
        
        y = [0] * len(f.x)
        y[0] = f.y0
        
        for i in range(1, len(f.x)):
            
            d1 = f.get_derivative(f.x[i - 1], f.y[i - 1])
            d2 = f.get_derivative(f.x[i - 1] + f.h/2, f.y[i - 1] + f.h * d1/2)
            d3 = f.get_derivative(f.x[i - 1] + f.h/2, f.y[i - 1] + f.h * d2/2)
            d4 = f.get_derivative(f.x[i - 1] + f.h, f.y[i - 1] + f.h * d3)
            
            d = h * (d1 + 2 * d2 + 2 * d3 + d4)/6
            y[i] = y[i - 1] + d #augmentation
            
            
        return y
    
#print('To plot graph for funtion enter x0, y0, X, N')

e = Equation(0.0, 1.0, 5.0, 100000.0)
res = (Numeric_methods().euler_method(e))
print(res[100000])